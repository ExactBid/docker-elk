input {
	tcp {
		port => 5000
	}
}

filter {
	json {
		# elevate the message data to the root of the document
		source => "message"
	}

	mutate {
		add_field => { "[@metadata][product]" => "%{product}" }
		remove_field => [product]
	}

	date {
		match => [ "timestamp" , "ISO8601" ]
	}

	if [clientIP] {
		geoip {
			source => "clientIP"
		}
	}

	if [@metadata][product] == "rims" and [contextData] {
		grok {
			match => { "contextData" => "duration=(?<elapsed_time>%{NUMBER})" }
		}
		grok {
			match => { "contextData" => "method=(?<method>%{DATA})\|" }
		}
	}
}

output {
	#stdout { codec => rubydebug }
	elasticsearch {
		hosts => "elasticsearch:9200"
		user => elastic
		password => changeme
		index => "%{[@metadata][product]}-index-%{+YYYY.MM.dd}"
		template_name => "%{[@metadata][product]}-index-template"
		# For now, we put the templates in place by hand. That's because file 
		# paths cannot be templated. See:
		# https://github.com/logstash-plugins/logstash-output-elasticsearch/issues/344
		#template => "/usr/share/logstash/templates/rims-index-template.json"
		#template_overwrite => true
	}
}
